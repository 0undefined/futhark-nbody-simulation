We implemented the Barnes Hut algorithm in
\link{Futhark}{https://futhark-lang.org/}: a purely functional,
data parallel, programming language.

We ended up not using an octree -- as the traditional BH is implemented -- due
to the complexity of the implementation and time constraints and used a radix
tree which we traverse instead. It might be favorable to use an octree as an
equivalent octree is more shallow than a binary radix-tree. This is good since
it allows for more parallelism and reduces the number recursion steps needed to
traverse the tree.\\

\noindent
The BH algorithm requires the leaves to be sorted, using radix sort and
subsequently bubble sort would seem like the better option. Bubblesort because
the runtime on nearly or already sorted (best case) input is simply better than
radix sort, but using the bubblesort from the
\link{futhark sort library}{https://github.com/diku-dk/sorts/}
proved errornous, either because we used it wrong or because it has a bug -- we
never reached a conclusion to that, therefore we ended up using radix sort for
the steps, and since we sort the array anyway in each step we completely
abandoned sorting it before simulating any steps.

\subsection{Barnes Hut Tree}
% MK_radix_tree
%  -> duplicates
When constructing the tree for later traversel, we need to map all coordinates
by relative distance. This is done by first normalizing all posisitions,
applying Morton codes and then sorting all the pointmasses by said Morton code.
Next we calculate all average positions and sum masses for each branching node
in the tree. We currently do not handle duplicate Morton codes, which we suspect
may be the reason of our errornous calculations as we later discuss in
\autoref{sec:errors}. The result is a record with the leaves and nodes.

\subsection{Recursion and futhark}
% Discuss recursion in BH_fold
%  -> futhark cant recurse
Since futhark doesn't support recursion (which is specified in the BH algorithm)
we needed to use loops instead. We map over our Barnes Hut ``folding'' function
such that each pointmass is calculated individually. When looping through the
tree we accumulate the force.

\begin{Figure}
  \centering
\lstset{firstnumber=41}
\lstinputlisting[firstline=41,lastline=67]{../source/BHtree.fut}
\captionof{figure}{\texttt{BHtree.fut:41-67}}
\end{Figure}

\subsection{Threshold}

\subsection{Errors}\label{sec:errors}
When computing each step we experienced that it would in some cases we would get
Not-a-Number when constructing the BH-tree. This propagates quickly through the
whole input as NaN applied with any operator on any number yields NaN. Therefore
when we traverse the tree NaN values spreads very quickly.
