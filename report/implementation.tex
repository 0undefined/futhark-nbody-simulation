We implemented the Barnes Hut algorithm in
Futhark\cite{futhark}: a purely functional,
data parallel, programming language.

We ended up not using an octree -- as the traditional BH is implemented -- due
to the complexity of the implementation and time constraints and used a radix
tree which we traverse instead. It might be favorable to use an octree as an
equivalent octree is more shallow than a binary radix-tree. This is good since
it allows for more parallelism and reduces the number recursion steps needed to
traverse the tree.\\

\noindent
The BH algorithm requires the leaves to be sorted, using radix sort and
subsequently bubble sort would seem like the better option. Bubblesort because
the runtime on nearly or already sorted (best case) input is simply better than
radix sort, but using the bubblesort from the
\link{futhark sort library}{https://github.com/diku-dk/sorts/}
proved errornous, either because we used it wrong or because it has a bug -- we
never reached a conclusion to that, therefore we ended up using radix sort for
the steps, and since we sort the array anyway in each step we completely
abandoned sorting it before simulating any steps.

\subsection{Barnes Hut Tree}
The Barnes-Hut (BH) tree is constituted by leaf nodes which have a position, velocity and mass; inner-nodes which have a synthetic position\footnote{calculated as the  


% MK_radix_tree
%  -> duplicates
When constructing the tree for later traversel, we need to map all coordinates
by relative distance. This is done by first normalizing all posisitions,
applying Morton codes and then sorting all the pointmasses by said Morton code.
Next we calculate all average positions and sum masses for each branching node
in the tree. We currently do not handle duplicate Morton codes, which we suspect
may be the reason of our errornous calculations as we later discuss in
\autoref{sec:errors}. The result is a record with the leaves and nodes.

\subsection{Recursion and futhark}
% Discuss recursion in BH_fold
%  -> futhark cant recurse
Since futhark doesn't support recursion (which is specified in the BH algorithm)
we needed to use loops instead. We map over our Barnes Hut ``folding'' function
such that each pointmass is calculated individually. When looping through the
tree we accumulate the force. We accumulate the forces from each node, traverse
down the tree if the threshold allows it, calculate force from the parent node
otherwise, and return the accumulated sum of those forces.

\subsection{Threshold}
The threshold value is used to decide if traversal of a given inner nodes should go
deeper, or if the synthetic mass-point of the inner node should be used as
approximation for its childrens mass-points. \\


The threshold is calculated as the quotient between 'octnode-box-side-length' of
the given inner node, and the distance between the simulated pointmass and the
synthetic pointmass of the inner node. If this quotient is below some theta,
which value is fixed at compilation, then the approximation is used and the
traversal deeper into this branch of inner nodes stops. \\

Since our BH-tree is implemented as a radix-tree and not an octree the
'octnode-box-side-length' is not directly avaliable and must be calculated some
how. Luckly this can be done cheaply from information gathered during the
construction of the radix-tree; we have the length, \delta, of the longest
common prefix of the morton code to all the leaf-node that are (grand)children
to the given inner node. This \delta, with information on how the leaf-nodes
where transformed into unit-space for morton code calculation  
If a morton code is looked at 3-bits at a time, then it
can be interperted as the adress   



Need to calculate the box, problem whith unit space translation

Multiple approches
Just go with the x side of the box, which gives other problems
Make all unit space sides have the same magnetuide, though with loss of precision



\subsection{Errors}\label{sec:errors}
We occasionally get not-a-number values which propagates through the BH-tree in
a single step. We suspect this is happens when planets are in very close
proximity, giving them the same morton code. We do not handle cases like this
and the error is inconsistent between scenarios but consistent when given the
same scenario.

